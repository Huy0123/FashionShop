import Product from '../models/productModel.js';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { setConversationContext, getConversationContext, isImageConfirmation, getLastMentionedProduct } from './conversationContext.js';
import dotenv from 'dotenv';
dotenv.config();

// Simple in-memory cache for product context by roomId (or userId)
const productContextCache = {};

// Kh·ªüi t·∫°o Gemini AI (FREE 15 requests/minute - 1500 requests/day)
let genAI = null;
try {
   const apiKey = process.env.GEMINI_API_KEY?.trim();
   if (apiKey && apiKey.length > 10) {
      genAI = new GoogleGenerativeAI(apiKey);
      console.log('‚úÖ Gemini AI initialized successfully');
   } else {
      console.log('‚ö†Ô∏è Gemini API key not found or invalid');
   }
} catch (error) {
   console.error('‚ùå Failed to initialize Gemini AI:', error.message);
}

/**
 * T√¨m s·∫£n ph·∫©m ƒë∆°n gi·∫£n cho Gemini v·ªõi productType structure
 */
async function findProductsForGemini(message) {
   try {
      const lowerMessage = message.toLowerCase();
      let query = {};
      
      // Check if user is asking about a specific product by name OR selecting a product
      const isSpecificProductQuery = (lowerMessage.length > 20 && 
                                    /(√°o\s*thun.*|hoodie.*|sweater.*|qu·∫ßn.*)\s+\w+/i.test(message)) ||
                                    /(ƒëi|nha|v·∫≠y|ok|ƒë∆∞·ª£c|ch·ªçn|l·∫•y)\s*$/i.test(message.trim());
      
      if (isSpecificProductQuery) {
         // Search by partial name match for specific products
         const cleanMessage = lowerMessage.replace(/(ƒëi|nha|v·∫≠y|ok|ƒë∆∞·ª£c|ch·ªçn|l·∫•y)\s*$/i, '').trim();
         const keywords = cleanMessage.split(' ').filter(word => word.length > 2);
         if (keywords.length >= 2) {
            const searchPattern = keywords.slice(0, 6).join('.*'); // Take more keywords for better match
            query.name = { $regex: searchPattern, $options: 'i' };
            console.log(`üîç Searching by name pattern: "${searchPattern}"`);
         }
      } else {
         // Use productType detection for general queries
         const productTypeMap = [
            { key: 'Hoodie', regex: /(hoodie|hodie|hoody|√°o\s*kho√°c|√°o\s*c√≥\s*m≈©|kho√°c)/i },
            { key: 'Sweater', regex: /(sweater|swetter|√°o\s*len|√°o\s*·∫•m|len)/i },
            { key: 'T-shirt', regex: /(√°o\s*thun|t-shirt|tshirt|t\s*shirt|√°o\s*tee|thun(?!\s*(relaxed|ringer)))/i },
            { key: 'RelaxedFit', regex: /(relaxed\s*fit|√°o thun relaxed fit|relaxed)/i },
            { key: 'Ringer', regex: /(ringer|√°o thun ringer|vi·ªÅn)/i },
            { key: 'Jogger', regex: /(jogger|jooger|qu·∫ßn\s*th·ªÉ\s*thao|qu·∫ßn\s*d√†i|qu·∫ßn\s*·ªëng\s*su√¥ng|qu·∫ßn(?!\s*(short|sort)))/i }
         ];

         for (const { key, regex } of productTypeMap) {
            if (regex.test(lowerMessage)) {
               query.productType = key;
               console.log(`üéØ Detected productType: ${key} from message: "${message}"`);
               break;
            }
         }
      }

      console.log('üîç Gemini Query:', query);
      
      // T√¨m s·∫£n ph·∫©m - TƒÇNG LIMIT ƒë·ªÉ c√≥ ƒë·ªß s·∫£n ph·∫©m cho user request
      let products = await Product.find(query).sort({ bestseller: -1, date: -1 }).limit(10);
      
      // Fallback n·∫øu kh√¥ng t√¨m th·∫•y
      if (products.length === 0) {
         console.log('‚ö†Ô∏è No products found with specific query, trying bestsellers...');
         products = await Product.find({ bestseller: true }).sort({ date: -1 }).limit(10);
      }
      
      // Final fallback
      if (products.length === 0) {
         console.log('‚ö†Ô∏è No bestsellers found, trying any products...');
         products = await Product.find({}).sort({ date: -1 }).limit(5);
      }
      
      console.log(`üì¶ Found ${products.length} products for Gemini processing`);
      return products;
      
   } catch (error) {
      console.error('Error in findProductsForGemini:', error);
      return [];
   }
}

/**
 * Generate Gemini AI response v·ªõi Smart Image Logic
 */
export async function generateGeminiAI(message, roomId = null) {
   try {
      console.log(`ü§ñ Gemini AI Processing: "${message}"`);
      console.log(`üîç genAI status: ${genAI ? 'Initialized' : 'NULL - Using fallback'}`);
      
      // Check if user is asking for specific product type
      const hasSpecificProductType = /(hoodie|sweater|jogger|t-shirt|√°o thun|qu·∫ßn|ringer|relaxed)/i.test(message);
      
      // Check for image confirmation first - BUT NOT if asking for different product
      if (isImageConfirmation(message, roomId) && !hasSpecificProductType) {
         const lastProduct = getLastMentionedProduct(roomId);
         if (lastProduct && lastProduct.image && lastProduct.image.length > 0) {
            const price = Math.round(lastProduct.price / 1000) + 'k';
            console.log(`üì∏ Showing image for confirmed product: ${lastProduct.name}`);
            return {
               message: `D·∫°! ƒê√¢y l√† ·∫£nh s·∫£n ph·∫©m ·∫°! üòç\n\nüì∏ **${lastProduct.name}**\nüí∞ Gi√°: ${price}\nüìè Size: ${lastProduct.sizes?.join(', ') || 'S, M, L'}\nüéØ ${lastProduct.productType}\n\nS·∫£n ph·∫©m n√†y ƒë·∫πp l·∫Øm! B·∫°n th√≠ch kh√¥ng? ü•∞`,
               image: lastProduct.image[0]
            };
         }
      }

      if (!genAI) {
         // Fallback ƒë∆°n gi·∫£n khi kh√¥ng c√≥ Gemini
         console.log('‚ö†Ô∏è Using fallback response - Gemini not initialized');
         return "Xin ch√†o! üëã Chevai Fashion c√≥ ƒëa d·∫°ng s·∫£n ph·∫©m: T-shirt, Hoodie, Sweater, Jogger v√† nhi·ªÅu lo·∫°i kh√°c! B·∫°n mu·ªën xem g√¨? üòä";
      }
      
      console.log(`üöÄ Using real Gemini AI for: "${message}"`);
      
      // 1. Check if user is referring to a previous product (STRICTER CHECK)
      const context = getConversationContext(roomId);
      let isReferringToPrevious = /(√°o n√†y|s·∫£n ph·∫©m n√†y|c√°i n√†y|n√†y.*c√≥|c√≥.*n√†y|item n√†y|product n√†y)/i.test(message) &&
                                  !hasSpecificProductType;
      
      // 2. T√¨m s·∫£n ph·∫©m li√™n quan - ALWAYS SEARCH NEW if user mentions specific product type
      let products = [];
      
      if (isReferringToPrevious && context?.lastProducts?.length > 0) {
         // Use products from conversation context ONLY if no specific product type mentioned
         products = context.lastProducts;
         console.log(`üîó Using products from conversation context: ${products.length} items`);
      } else {
         // Find new products - CLEAR old context when searching for new products
         if (hasSpecificProductType && roomId) {
            console.log(`üîÑ Clearing old context - user asking for specific product type`);
            // Don't completely clear, but mark as new search
         }
         products = await findProductsForGemini(message);
      }
      console.log(`üõçÔ∏è Found ${products.length} products for Gemini`);
      
      // 3. T·∫°o context v·ªõi th√¥ng tin ·∫£nh theo productType structure
      let productContext = products.length > 0
         ? products.map((p, index) => {
            const price = Math.round(p.price / 1000) + 'k';
            const hasImage = p.image && p.image.length > 0 ? ' (c√≥ ·∫£nh)' : '';
            const productInfo = p.productType ? ` - ${p.productType}` : '';
            const sizes = p.sizes && p.sizes.length > 0 ? ` - Sizes c√≥ s·∫µn: ${p.sizes.join(', ')}` : ' - Kh√¥ng c√≥ th√¥ng tin size';
            // Shorten description but keep important info
            const description = p.description ? ` - ${p.description.substring(0, 80).replace(/\r\n/g, ' ')}...` : '';
            return `${index + 1}. **${p.name}**${productInfo} - ${price}${sizes}${hasImage}${description}`;
         }).join('\n\n')
         : 'Kh√¥ng c√≥ s·∫£n ph·∫©m c·ª• th·ªÉ.';

      // L∆∞u context s·∫£n ph·∫©m v√†o cache n·∫øu c√≥ roomId v√† c√≥ danh s√°ch
      if (roomId && products.length > 0) {
         productContextCache[roomId] = products;
      }

      // 4. Prompt cho Gemini - TH√îNG MINH KH√îNG HARD-CODE
      const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
      console.log('üéØ Using Gemini model: gemini-1.5-flash');
      const prompt = `B·∫°n l√† Ai-chan ü§ñ, tr·ª£ l√Ω th·ªùi trang th√¥ng minh c·ªßa Chevai Fashion.

QUAN TR·ªåNG: CH·ªà s·ª≠ d·ª•ng th√¥ng tin t·ª´ danh s√°ch s·∫£n ph·∫©m b√™n d∆∞·ªõi. KH√îNG t·ª± t·∫°o ra t√™n s·∫£n ph·∫©m, m√¥ t·∫£, hay th√¥ng tin n√†o kh√°c.

User h·ªèi: "${message}"

DANH S√ÅCH S·∫¢N PH·∫®M C√ì S·∫¥N:
${productContext}

QUY T·∫ÆC B·∫ÆT BU·ªòC:
1. N·∫øu user n√≥i T√äN S·∫¢N PH·∫®M C·ª§ TH·ªÇ (c√≥ trong danh s√°ch) + "ƒëi/nha/v·∫≠y/ok" ‚Üí Hi·ªÉu ƒë√¢y l√† CH·ªåN s·∫£n ph·∫©m ƒë√≥, tr·∫£ l·ªùi chi ti·∫øt v·ªÅ s·∫£n ph·∫©m ƒë√≥ v·ªõi gi√°, m√¥ t·∫£, size
2. N·∫øu user h·ªèi v·ªÅ SIZE/C√ÇN N·∫∂NG ‚Üí CH·ªà s·ª≠ d·ª•ng sizes c√≥ S·∫¥N c·ªßa t·ª´ng s·∫£n ph·∫©m trong danh s√°ch. T∆∞ v·∫•n theo nguy√™n t·∫Øc:
   - Xem sizes c√≥ s·∫µn c·ªßa t·ª´ng s·∫£n ph·∫©m trong danh s√°ch
   - T∆∞ v·∫•n size ph√π h·ª£p: 45-55kg (S), 55-65kg (M), 65-75kg (L), 75kg+ (XL)
   - CH·ªà gi·ªõi thi·ªáu s·∫£n ph·∫©m c√≥ size ph√π h·ª£p v·ªõi c√¢n n·∫∑ng
   - N·∫øu s·∫£n ph·∫©m kh√¥ng c√≥ size ph√π h·ª£p ‚Üí Kh√¥ng gi·ªõi thi·ªáu s·∫£n ph·∫©m ƒë√≥
   - V√ç D·ª§: User 60kg ‚Üí Ch·ªâ gi·ªõi thi·ªáu s·∫£n ph·∫©m n√†o c√≥ size M trong danh s√°ch
3. N·∫øu user h·ªèi "√°o n√†y", "s·∫£n ph·∫©m n√†y" m√† kh√¥ng r√µ l√† g√¨ ‚Üí H·ªèi l·∫°i: "B·∫°n ƒëang mu·ªën h·ªèi v·ªÅ √°o n√†o nh·ªâ? ü§î"
4. CH·ªà gi·ªõi thi·ªáu s·∫£n ph·∫©m c√≥ TRONG DANH S√ÅCH TR√äN
5. KH√îNG t·ª± t·∫°o ra: "√°o thun ki·ªÉu Ringer", "in h√¨nh anh ƒë√†o", hay b·∫•t k·ª≥ m√¥ t·∫£ n√†o kh√¥ng c√≥
6. S·ª≠ d·ª•ng CH√çNH X√ÅC t√™n s·∫£n ph·∫©m t·ª´ danh s√°ch
7. Tr·∫£ l·ªùi ng·∫Øn g·ªçn, th√¢n thi√™n nh∆∞ ng∆∞·ªùi b·∫°n
8. N·∫øu c√≥ s·∫£n ph·∫©m ph√π h·ª£p: gi·ªõi thi·ªáu v·ªõi gi√° v√† th√¥ng tin CH√çNH X√ÅC
9. K·∫øt th√∫c b·∫±ng c√¢u h·ªèi ƒë·ªÉ ti·∫øp t·ª•c chat
10. N·∫øu kh√¥ng li√™n quan th·ªùi trang: "M√¨nh ch·ªâ h·ªó tr·ª£ v·ªÅ th·ªùi trang Chevai th√¥i! üòä"

V√ç D·ª§ T∆Ø V·∫§N SIZE:
User: "60kg th√¨ m√¨nh n√™n m·∫∑c size bao nhi√™u"
‚Üí Ki·ªÉm tra danh s√°ch, t√¨m s·∫£n ph·∫©m c√≥ size M, ch·ªâ gi·ªõi thi·ªáu nh·ªØng s·∫£n ph·∫©m ƒë√≥
‚Üí "V·ªõi c√¢n n·∫∑ng 60kg, b·∫°n n√™n m·∫∑c size M. Trong danh s√°ch c√≥: [T√™n s·∫£n ph·∫©m c√≥ size M] - [gi√°] - Size: [ch·ªâ li·ªát k√™ sizes th·ª±c t·∫ø]"

V√ç D·ª§ CH·ªåN S·∫¢N PH·∫®M:
User: "√Åo Thun Ringer Relaxed Fit Tropical Cherries Sweet ƒëi"
‚Üí Hi·ªÉu: User ch·ªçn s·∫£n ph·∫©m n√†y, tr·∫£ l·ªùi chi ti·∫øt v·ªÅ n√≥ v·ªõi sizes th·ª±c t·∫ø

V√ç D·ª§ SAI: "√°o thun ki·ªÉu Ringer Relaxed Fit in h√¨nh anh ƒë√†o" ‚Üê KH√îNG ƒê∆Ø·ª¢C L√ÄM
V√ç D·ª§ ƒê√öNG: S·ª≠ d·ª•ng t√™n t·ª´ danh s√°ch: "√Åo Thun Relaxed Fit Porsche Berry Porsche T-Shirt"`;

      const result = await model.generateContent(prompt);
      const response = result.response.text();

      console.log(`ü§ñ Gemini response: ${response.length} chars`);
      console.log(`üìù Response content: ${response.substring(0, 100)}...`);

      // 5. Ch·ªâ l·∫•y s·∫£n ph·∫©m theo s·ªë th·ª© t·ª± n·∫øu AI v·ª´a tr·∫£ v·ªÅ danh s√°ch context (∆∞u ti√™n l·∫•y t·ª´ cache n·∫øu c√≥ roomId)
      let recommendedProduct = null;
      let contextProducts = products;
      if (roomId && productContextCache[roomId]) {
         contextProducts = productContextCache[roomId];
      }
      const hasProductList = contextProducts && contextProducts.length > 0;
      const productIndexMatch = hasProductList && message.match(/(?:s·∫£n ph·∫©m|item|product)\s*(?:s·ªë\s*)?(\d+)/i);
      
      if (hasProductList && productIndexMatch) {
         const requestedIndex = parseInt(productIndexMatch[1]) - 1;
         if (requestedIndex >= 0 && requestedIndex < contextProducts.length) {
            recommendedProduct = contextProducts[requestedIndex];
            console.log(`üéØ Found product by INDEX: #${requestedIndex + 1} - ${recommendedProduct.name}`);
         } else {
            console.log(`‚ö†Ô∏è User requested product #${requestedIndex + 1} but only have ${contextProducts.length} products`);
            return {
               message: `Xin l·ªói b·∫°n! üòÖ Hi·ªán t·∫°i m√¨nh ch·ªâ c√≥ ${contextProducts.length} s·∫£n ph·∫©m th√¥i (t·ª´ 1 ƒë·∫øn ${contextProducts.length}).\n\nB·∫°n mu·ªën xem s·∫£n ph·∫©m n√†o? üõçÔ∏è`,
               image: null
            };
         }
      }
      // NEW: T√¨m s·∫£n ph·∫©m theo t√™n khi user search c·ª• th·ªÉ
      else if (hasProductList && /(cho|xem|mu·ªën|t√¨m)\s*(s·∫£n ph·∫©m|√°o|qu·∫ßn)/i.test(message)) {
         // T√¨m s·∫£n ph·∫©m c√≥ t√™n kh·ªõp nh·∫•t v·ªõi query
         const productNameInMessage = message.toLowerCase();
         for (const product of contextProducts) {
            if (product.name && productNameInMessage.includes(product.name.toLowerCase().substring(0, 20))) {
               recommendedProduct = product;
               console.log(`üéØ Found product by NAME: ${recommendedProduct.name}`);
               break;
            }
         }
         // Fallback: n·∫øu kh√¥ng t√¨m th·∫•y theo t√™n, l·∫•y s·∫£n ph·∫©m ƒë·∫ßu ti√™n
         if (!recommendedProduct && contextProducts.length > 0) {
            recommendedProduct = contextProducts[0];
            console.log(`üéØ Using first product as fallback: ${recommendedProduct.name}`);
         }
      }
      
      // N·∫øu user h·ªèi c√¢u m·ªõi kh√¥ng li√™n quan (nh∆∞ng gi·ªØ context cho confirmation)
      const isConfirmation = /^(c√≥|ok|yes|ƒë∆∞·ª£c|ƒë·ªìng\s*√Ω|·ª´|·ª´m|v√¢ng)$/i.test(message.trim());
      if (roomId && !productIndexMatch && !isConfirmation) {
         // Ch·ªâ x√≥a context n·∫øu kh√¥ng ph·∫£i confirmation v√† kh√¥ng ph·∫£i ti·∫øp t·ª•c cu·ªôc tr√≤ chuy·ªán
         const isContinuation = /(cho|xem|mu·ªën|t√¨m)\s*(s·∫£n ph·∫©m|√°o|qu·∫ßn|·∫£nh|h√¨nh)/i.test(message);
         if (!isContinuation) {
            delete productContextCache[roomId];
         }
      }

      // 5. CH·ªà hi·ªÉn th·ªã ·∫£nh khi:
      // - User h·ªèi c·ª• th·ªÉ v·ªÅ 1 s·∫£n ph·∫©m (theo s·ªë th·ª© t·ª± ho·∫∑c product name)
      // - User y√™u c·∫ßu xem ·∫£nh 
      // - User confirm (c√≥, ok, yes) sau khi ƒë∆∞·ª£c h·ªèi
      // - AI recommend 1 s·∫£n ph·∫©m c·ª• th·ªÉ
      // - AI response c√≥ nh·∫Øc ƒë·∫øn "·∫£nh" ho·∫∑c "image"
      const userWantsImage = /(·∫£nh|h√¨nh|image|xem|show|cho.*xem|mu·ªën.*xem|cho.*m√¨nh.*xem)/i.test(message);
      const userAsksSpecificProduct = /(?:s·∫£n ph·∫©m|item|product)\s*(?:s·ªë\s*)?\d+/i.test(message) || /(cho|xem|mu·ªën|t√¨m)\s*(s·∫£n ph·∫©m|√°o|qu·∫ßn)/i.test(message);
      const userConfirms = /^(c√≥|ok|yes|ƒë∆∞·ª£c|ƒë·ªìng\s*√Ω|·ª´|·ª´m|v√¢ng)$/i.test(message.trim());
      const responseMentionsImage = /(·∫£nh|image|h√¨nh)/i.test(response);
      const isRecommendingProduct = /(?:s·∫£n ph·∫©m s·ªë|item \d+|product \d+)/i.test(response);

      // CH·ªà show ·∫£nh khi c√≥ s·∫£n ph·∫©m ph√π h·ª£p v√† user c√≥ intent xem ho·∫∑c AI recommend c·ª• th·ªÉ
      const hasValidProduct = recommendedProduct !== null;
      const shouldShowImage = hasValidProduct && (userWantsImage || userAsksSpecificProduct || userConfirms || responseMentionsImage || isRecommendingProduct);

      if (shouldShowImage && recommendedProduct.image && recommendedProduct.image.length > 0) {
         const reason = userAsksSpecificProduct ? 'specific product requested' : 
                       responseMentionsImage ? 'AI mentioned image' : 
                       isRecommendingProduct ? 'AI recommending product' :
                       userConfirms ? 'user confirmed' :
                       'image requested';
         console.log(`üì∏ Adding relevant image from: ${recommendedProduct.name} (reason: ${reason})`);
         return {
            message: response,
            image: recommendedProduct.image[0]
         };
      }

      // 6. Store conversation context for product mentions and image requests
      const isAskingForImage = /(mu·ªën xem ·∫£nh|c√≥ mu·ªën xem|xem ·∫£nh kh√¥ng|want to see|see image|·∫£nh c·ªßa s·∫£n ph·∫©m|·∫£nh kh√¥ng)/i.test(response);
      const mentionsProduct = /(hoodie|sweater|jogger|t-shirt|√°o|qu·∫ßn)/i.test(response) && contextProducts.length > 0;
      
      if (roomId && (isAskingForImage || mentionsProduct)) {
         const productToStore = recommendedProduct || (contextProducts.length > 0 ? contextProducts[0] : null);
         if (productToStore) {
            setConversationContext(roomId, {
               lastAction: isAskingForImage ? 'asked_for_image' : 'mentioned_product',
               lastProduct: productToStore,
               lastProducts: contextProducts, // Store all products for choice
               lastResponse: response,
               aiProvider: 'Gemini'
            });
            console.log(`üí≠ Stored context - ${isAskingForImage ? 'asking for image' : 'mentioned product'}: ${productToStore.name}`);
         }
      }

      // 7. KH√îNG c√≥ ·∫£nh khi kh√¥ng c·∫ßn thi·∫øt
      console.log(`üìù Returning text-only response (${hasValidProduct ? 'product found but no image needed' : 'no matching product'})`);
      return response;

   } catch (error) {
      console.error('üö® Gemini AI Error:', error);

      // If it's a 503 Service Unavailable or rate limit error, throw it so hybrid can fallback to custom AI
      if (error.status === 503 || error.status === 429 || error.message?.includes('overloaded') || error.message?.includes('quota')) {
         console.log('üîÑ Gemini overloaded/quota exceeded - throwing error for hybrid fallback');
         throw error;
      }

      // For other errors, provide intelligent fallback
      const keywords = ['ch√†o', 'hello', 'hi', 'xin ch√†o', '√°o', 'qu·∫ßn', 'gi√°', 'price'];
      const hasKeyword = keywords.some(keyword => message.toLowerCase().includes(keyword));

      if (hasKeyword) {
         return "Xin ch√†o! üëã M√¨nh l√† AI c·ªßa Chevai Fashion! Chevai c√≥ T-shirt, Hoodie, Sweater, Jogger v√† nhi·ªÅu s·∫£n ph·∫©m th·ªùi trang ƒë·∫πp l·∫Øm! B·∫°n mu·ªën xem g√¨? üòä‚ú®";
      }

      return "Xin l·ªói, m√¨nh ƒëang g·∫∑p s·ª± c·ªë nh·ªè! üòÖ Th·ª≠ h·ªèi l·∫°i ho·∫∑c li√™n h·ªá admin nh√©! üõ†Ô∏è";
   }
}

/**
 * Ki·ªÉm tra c√≥ n√™n d√πng Gemini kh√¥ng - C·∫¢I TI·∫æN
 */
export function shouldGeminiRespond(message) {
   const trimmed = message.trim();
   
   // Qu√° ng·∫Øn ho·∫∑c ch·ªâ c√≥ k√Ω t·ª± ƒë·∫∑c bi·ªát
   if (trimmed.length < 2 || /^[\d\s\-_.,!?]*$/i.test(trimmed)) {
      return false;
   }
   
   // Ch·ªâ emoji ho·∫∑c sticker
   if (/^[\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{1F700}-\u{1F77F}\u{1F780}-\u{1F7FF}\u{1F800}-\u{1F8FF}\u{1F900}-\u{1F9FF}\u{1FA00}-\u{1FA6F}\u{1FA70}-\u{1FAFF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}]+$/u.test(trimmed)) {
      return false;
   }
   
   // Tin nh·∫Øn admin only
   if (/(admin\s+only|private\s+message)/i.test(trimmed)) {
      return false;
   }
   
   // C√≥ t·ª´ kh√≥a th·ªùi trang ho·∫∑c c√¢u h·ªèi h·ª£p l·ªá ho·∫∑c y√™u c·∫ßu xem h√¨nh
   const fashionKeywords = /(√°o|qu·∫ßn|th·ªùi trang|fashion|clothes|shirt|pants|hoodie|sweater|jogger|tshirt|ringer|relaxed)/i;
   const validQuestion = /(g√¨|n√†o|sao|nh∆∞|khi|c√≥|bao|price|gi√°|size|m√†u|color)/i;
   const greeting = /(ch√†o|hello|hi|xin)/i;
   const imageRequest = /(h√¨nh|·∫£nh|image|photo|pic|xem|show|cho.*xem|mu·ªën.*xem)/i;
   
   return fashionKeywords.test(trimmed) || validQuestion.test(trimmed) || greeting.test(trimmed) || imageRequest.test(trimmed);
}

/**
 * Stats v·ªÅ Gemini usage
 */
export function getGeminiStats() {
   return {
      provider: 'Google Gemini',
      cost: 'FREE',
      limits: '15 requests/minute, 1500/day',
      getApiKey: 'https://makersuite.google.com/app/apikey'
   };
}
